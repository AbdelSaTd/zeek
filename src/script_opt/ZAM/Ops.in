# Templates used to generate virtual functions, opcodes, and evaluation
# code for compiled code.

########## Unary Ops ##########

assign-op Assign
type V

assign-op Field-LHS-Assign
op1-read
type F

unary-expr-op Clone
no-const
op-type X
set-type $1
set-type2 $2
eval	auto v = frame[z.v2].ToVal(z.t2)->Clone();
	AssignV1(BuildVal(v, z.t))

unary-expr-op Size
no-const
op-type I U D A N S T V *
explicit-result-type
set-type $1
set-type2 $2
eval-type I	$$ = ZVal(bro_int_t($1 < 0 ? -$1 : $1));
eval-type U	$$ = ZVal($1);
eval-type D	$$ = ZVal($1 < 0 ? -$1 : $1);
eval-type A	$$ = ZVal(bro_uint_t($1->AsAddr().GetFamily() == IPv4 ? 32 : 128));
eval-type N	$$ = ZVal(pow(2.0, double(128 - $1->AsSubNet().LengthIPv6())));
eval-type S	$$ = ZVal(bro_uint_t($1->Len()));
eval-type T	$$ = ZVal(bro_uint_t($1->Size()));
eval-type V	$$ = ZVal(bro_uint_t($1->Size()));
eval	auto v = frame[z.v2].ToVal(z.t2)->SizeVal();
	$$ = BuildVal(v, z.t);

unary-expr-op Not
op-type I
eval ! $1

unary-expr-op Complement
op-type U
eval ~ $1

unary-expr-op Positive
op-type I U D
vector
eval $1

unary-expr-op Negate
op-type I U D
vector
eval -$1

op IncrI
op1-read-write
type V
eval	++frame[z.v1].int_val;

op IncrU
op1-read-write
type V
eval	++frame[z.v1].uint_val;

op DecrI
op1-read-write
type V
eval	--frame[z.v1].int_val;

op DecrU
op1-read-write
type V
eval	--frame[z.v1].uint_val;

unary-op AppendTo
# Note, even though it feels like appending both reads and modifies
# its first operand, for our purposes it just reads it (to get the
# aggregate), and then modifies its *content* but not the operand's
# value itself.
op1-read
set-type $2
eval	auto copy = CopyVal($1);
	auto& vv = frame[z.v1].vector_val->RawVec();
	vv->push_back(copy);

internal-op AppendToField
type VVi
op1-read
eval	auto v = CopyVal(frame[z.v2]);
	auto fvv = frame[z.v1].record_val->GetField(z.v3)->AsVectorVal();
	if ( fvv )
		fvv->RawVec()->push_back(v);
	else
		ZAM_run_time_error(z.loc, util::fmt("field value missing: $%s", frame[z.v1].record_val->GetType()->AsRecordType()->FieldName(z.v3)));

internal-op AppendToField
type VCi
op1-read
eval	auto v = CopyVal(z.c);
	auto fvv = frame[z.v1].record_val->GetField(z.v2)->AsVectorVal();
	if ( fvv )
		fvv->RawVec()->push_back(v);
	else
		ZAM_run_time_error(z.loc, util::fmt("field value missing: $%s", frame[z.v1].record_val->GetType()->AsRecordType()->FieldName(z.v2)));

unary-expr-op Cast
op-type X
set-type $1
set-type2 $2
eval	std::string error;
	auto rhs = frame[z.v2].ToVal(z.t2);
	auto res = cast_value(rhs, z.t, error);
	if ( res )
		AssignV1(BuildVal(res, z.t))
	else
		ZAM_run_time_error(z.loc, error.c_str());

# Cast an "any" type to the given type.  Only needed for type-based swith
# statements.
internal-op Cast-Any
type VV
eval	std::string error;
	auto res = cast_value({NewRef{}, frame[z.v2].any_val}, z.t, error);
	if ( res )
		AssignV1(BuildVal(res, z.t))
	else
		ZAM_run_time_error(z.loc, error.c_str());

direct-unary-op Is Is

internal-op Is
type VV
eval	auto rhs = frame[z.v2].ToVal(z.t2).get();
	frame[z.v1].int_val = can_cast_value_to_type(rhs, z.t.get());

########## Binary Ops ##########

binary-expr-op Add
op-type I U D S
vector
eval $1 + $2
eval-type S	vector<const String*> strings;
		strings.push_back($1->AsString());
		strings.push_back($2->AsString());
		auto res = new StringVal(concatenate(strings));
		$$ = res;

binary-expr-op Sub
op-type I U D T
vector
eval $1 - $2
#
eval-type T	auto v = $1->Clone();
		auto s = v.release()->AsTableVal();
		$2->RemoveFrom(s);
		$$ = s;

binary-expr-op Times
op-type I U D
vector
eval $1 * $2

binary-expr-op Divide
op-type I U D
vector
#
eval-pre	if ( $2 == 0 )
			{
			ZAM_run_time_error(z.loc, "division by zero");
			break;
			}
eval $1 / $2
#
eval-mixed A I	auto mask = static_cast<uint32_t>($2);
		auto a = $1->AsAddr();
		if ( a.GetFamily() == IPv4 && mask > 32 )
			ZAM_run_time_error(z.loc, util::fmt("bad IPv4 subnet prefix length: %" PRIu32, mask));
		if ( a.GetFamily() == IPv6 && mask > 128 )
			ZAM_run_time_error(z.loc, util::fmt("bad IPv6 subnet prefix length: %" PRIu32, mask));
		auto v = make_intrusive<SubNetVal>(a, mask);
		Unref(frame[z.v1].subnet_val);
		frame[z.v1].subnet_val = v.release();

binary-expr-op Mod
op-type I U
vector
eval-pre	if ( $2 == 0 )
			{
			ZAM_run_time_error(z.loc, "modulo by zero");
			break;
			}
eval $1 % $2

binary-expr-op And-And
op-type I
vector
eval bro_int_t($1 && $2)

binary-expr-op Or-Or
op-type I
vector
eval bro_int_t($1 || $2)

binary-expr-op And
op-type U P T
vector
eval $1 & $2
#
eval-type P	$$ = new PatternVal(RE_Matcher_conjunction($1->AsPattern(), $2->AsPattern()));
#
eval-type T	$$ = $1->Intersection(*$2).release();

binary-expr-op Or
op-type U P T
vector
eval $1 | $2
#
eval-type P	$$ = new PatternVal(RE_Matcher_disjunction($1->AsPattern(), $2->AsPattern()));
#
eval-type T	auto v = $1->Clone();
		auto s = v.release()->AsTableVal();
		(void) $2->AddTo(s, false, false);
		$$ = s;

binary-expr-op Xor
op-type U
vector
eval $1 ^ $2

########## Relationals ##########

rel-expr-op LT
op-type I U D S T A
vector
eval $1 < $2
eval-type S	Bstr_cmp($1->AsString(), $2->AsString()) < 0
eval-type T	$1->IsSubsetOf(*$2) && $1->Size() < $2->Size()
eval-type A	$1->AsAddr() < $2->AsAddr()

rel-expr-op LE
op-type I U D S T A
vector
eval $1 <= $2
eval-type S	Bstr_cmp($1->AsString(), $2->AsString()) <= 0
eval-type T	$1->IsSubsetOf(*$2)
eval-type A	$1->AsAddr() < $2->AsAddr() || $1->AsAddr() == $2->AsAddr()

rel-expr-op EQ
op-type I U D S T A N F
vector
eval $1 == $2
eval-type S	Bstr_cmp($1->AsString(), $2->AsString()) == 0
eval-type T	$1->EqualTo(*$2)
eval-type A	$1->AsAddr() == $2->AsAddr()
eval-type N	$1->AsSubNet() == $2->AsSubNet()
eval-type F	util::streq($1->Name(), $2->Name())
eval-mixed P S	$1->MatchExactly($2->AsString())

rel-expr-op NE
op-type I U D S T A N F
vector
eval $1 != $2
eval-type S	Bstr_cmp($1->AsString(), $2->AsString()) != 0
eval-type T	! $1->EqualTo(*$2)
eval-type A	$1->AsAddr() != $2->AsAddr()
eval-type N	$1->AsSubNet() != $2->AsSubNet()
eval-type F	! util::streq($1->Name(), $2->Name())
eval-mixed P S	! $1->MatchExactly($2->AsString())

# Note, canonicalization means that GE and GT shouldn't occur
# for Sets (type T).
rel-expr-op GE
op-type I U D S A
vector
eval $1 >= $2
eval-type S	Bstr_cmp($1->AsString(), $2->AsString()) >= 0
eval-type A	! ($1->AsAddr() < $2->AsAddr())

rel-expr-op GT
op-type I U D S A
vector
eval $1 > $2
eval-type S	Bstr_cmp($1->AsString(), $2->AsString()) > 0
eval-type A	! ($1->AsAddr() < $2->AsAddr()) && $1->AsAddr() != $2->AsAddr()

########## Nonuniform Expressions ##########

assign-op Field
type R
field-op
assign-val v
eval	auto r = frame[z.v2].record_val;
	auto rv = r->RawOptField(z.v3);
	if ( ! rv )
		{
		auto def = r->GetType<RecordType>()->FieldDefault(z.v3);
		if ( def )
			rv = ZVal(def, z.t);
		else
			{
			ZAM_run_time_error(z.loc, util::fmt("field value missing: $%s", r->GetType()->AsRecordType()->FieldName(z.v3)));
			break;
			}
		}
	auto v = *rv;

expr-op Has-Field
type VRi
includes-field-op
eval	frame[z.v1].int_val = frame[z.v2].record_val->HasField(z.v3);

internal-op Has-Field-Cond
op1-read
type VVV
eval	if ( ! frame[z.v1].record_val->HasField(z.v2) )
		BRANCH(v3)

internal-op Not-Has-Field-Cond
op1-read
type VVV
eval	if ( frame[z.v1].record_val->HasField(z.v2) )
		BRANCH(v3)

expr-op In
type VVV
custom-method return CompileInExpr(n1, n2, n3);
no-eval

expr-op In
type VCV
custom-method return CompileInExpr(n1, c, n2);
no-eval

expr-op In
type VVC
custom-method return CompileInExpr(n1, n2, c);
no-eval

internal-op P-In-S
type VVV
eval	frame[z.v1].int_val = frame[z.v2].re_val->MatchAnywhere(frame[z.v3].string_val->AsString()) != 0;

internal-op P-In-S
type VCV
eval	frame[z.v1].int_val = z.c.re_val->MatchAnywhere(frame[z.v2].string_val->AsString()) != 0;

internal-op P-In-S
type VVC
eval	frame[z.v1].int_val = frame[z.v2].re_val->MatchAnywhere(z.c.string_val->AsString()) != 0;

internal-binary-op S-In-S
op-accessor string_val
op-type I
eval	auto sc = reinterpret_cast<const unsigned char*>(op1->CheckString());
	auto cmp = util::strstr_n(op2->Len(), op2->Bytes(), op1->Len(), sc);
	$$ = cmp != -1;

internal-binary-op A-In-S
op1-accessor addr_val
op2-accessor subnet_val
op-type I
eval	$$ = op2->Contains(op1->AsAddr());


# Handled differently because of the unusual middle argument.
op L-In-T
type VLV
custom-method return CompileInExpr(n1, l, n2);
no-eval

op L-In-T
type VLC
custom-method return CompileInExpr(n, l, c);
no-eval

op L-In-Vec
type VLV
custom-method return CompileInExpr(n1, l, n2);
no-eval

op L-In-Vec
type VLC
custom-method return CompileInExpr(n, l, c);
no-eval


internal-op Val-Is-In-Table
type VVV
# No set-type as these are internal ops.
eval	auto op1 = frame[z.v2].ToVal(z.t);
	frame[z.v1].int_val = frame[z.v3].table_val->Find(op1) != nullptr;

internal-op Val-Is-In-Table-Cond
op1-read
type VVV
eval	auto op1 = frame[z.v1].ToVal(z.t);
	if ( ! frame[z.v2].table_val->Find(op1) )
		BRANCH(v3)

internal-op Val-Is-Not-In-Table-Cond
op1-read
type VVV
eval	auto op1 = frame[z.v1].ToVal(z.t);
	if ( frame[z.v2].table_val->Find(op1) )
		BRANCH(v3)

# Variants for indexing two values, one of which might be a constant.
# We set the instructions's *second* type to be that of the first variable
# index.  We get the type of the second variable (if any) by digging it
# out of the table's type.  For a constant in either position, we use
# the main instruction type, as always.

internal-op Val2-Is-In-Table
type VVVV
eval	auto& tt_ind = frame[z.v4].table_val->GetType()->AsTableType()->GetIndexTypes();
	auto op1 = frame[z.v2].ToVal(z.t2);
	auto op2 = frame[z.v3].ToVal(tt_ind[1]);
	ListVal lv(TYPE_ANY);
	lv.Append(op1);
	lv.Append(op2);
	frame[z.v1].int_val = frame[z.v4].table_val->Find({NewRef{}, &lv}) != nullptr;

internal-op Val2-Is-In-Table-Cond
op1-read
type VVVV
eval	auto& tt_ind = frame[z.v3].table_val->GetType()->AsTableType()->GetIndexTypes();
	auto op1 = frame[z.v1].ToVal(z.t2);
	auto op2 = frame[z.v2].ToVal(tt_ind[1]);
	ListVal lv(TYPE_ANY);
	lv.Append(op1);
	lv.Append(op2);
	if ( ! frame[z.v3].table_val->Find({NewRef{}, &lv}) )
		BRANCH(v4)

internal-op Val2-Is-Not-In-Table-Cond
op1-read
type VVVV
eval	auto& tt_ind = frame[z.v3].table_val->GetType()->AsTableType()->GetIndexTypes();
	auto op1 = frame[z.v1].ToVal(z.t2);
	auto op2 = frame[z.v2].ToVal(tt_ind[1]);
	ListVal lv(TYPE_ANY);
	lv.Append(op1);
	lv.Append(op2);
	if ( frame[z.v3].table_val->Find({NewRef{}, &lv}) )
		BRANCH(v4)

internal-op Val2-Is-In-Table
type VVVC
eval	auto op1 = frame[z.v2].ToVal(z.t2);
	auto op2 = z.c.ToVal(z.t);
	ListVal lv(TYPE_ANY);
	lv.Append(op1);
	lv.Append(op2);
	frame[z.v1].int_val = frame[z.v3].table_val->Find({NewRef{}, &lv}) != nullptr;

internal-op Val2-Is-In-Table-Cond
op1-read
type VVVC
eval	auto op1 = frame[z.v1].ToVal(z.t2);
	auto op2 = z.c.ToVal(z.t);
	ListVal lv(TYPE_ANY);
	lv.Append(op1);
	lv.Append(op2);
	if ( ! frame[z.v2].table_val->Find({NewRef{}, &lv}) )
		BRANCH(v3)

internal-op Val2-Is-Not-In-Table-Cond
op1-read
type VVVC
eval	auto op1 = frame[z.v1].ToVal(z.t2);
	auto op2 = z.c.ToVal(z.t);
	ListVal lv(TYPE_ANY);
	lv.Append(op1);
	lv.Append(op2);
	if ( frame[z.v2].table_val->Find({NewRef{}, &lv}) )
		BRANCH(v3)

internal-op Val2-Is-In-Table
type VVCV
eval	auto op1 = z.c.ToVal(z.t);
	auto op2 = frame[z.v2].ToVal(z.t2);
	ListVal lv(TYPE_ANY);
	lv.Append(op1);
	lv.Append(op2);
	frame[z.v1].int_val = frame[z.v3].table_val->Find({NewRef{}, &lv}) != nullptr;

internal-op Val2-Is-In-Table-Cond
op1-read
type VVCV
eval	auto op1 = z.c.ToVal(z.t);
	auto op2 = frame[z.v1].ToVal(z.t2);
	ListVal lv(TYPE_ANY);
	lv.Append(op1);
	lv.Append(op2);
	if ( ! frame[z.v2].table_val->Find({NewRef{}, &lv}) )
		BRANCH(v3)

internal-op Val2-Is-Not-In-Table-Cond
op1-read
type VVCV
eval	auto op1 = z.c.ToVal(z.t);
	auto op2 = frame[z.v1].ToVal(z.t2);
	ListVal lv(TYPE_ANY);
	lv.Append(op1);
	lv.Append(op2);
	if ( frame[z.v2].table_val->Find({NewRef{}, &lv}) )
		BRANCH(v3)


internal-op Const-Is-In-Table
type VCV
eval	auto op1 = z.c.ToVal(z.t);
	frame[z.v1].int_val = frame[z.v2].table_val->Find(op1) != nullptr;

internal-op Const-Is-In-Table-Cond
op1-read
type VVC
eval	auto op1 = z.c.ToVal(z.t);
	if ( ! frame[z.v1].table_val->Find(op1) )
		BRANCH(v2)

internal-op Const-Is-Not-In-Table-Cond
op1-read
type VVC
eval	auto op1 = z.c.ToVal(z.t);
	if ( frame[z.v1].table_val->Find(op1) )
		BRANCH(v2)

internal-op List-Is-In-Table
type VV
eval	auto op1 = z.aux->ToListVal(frame);
	frame[z.v1].int_val = frame[z.v2].table_val->Find(op1) != nullptr;

internal-op List-Is-In-Table
type VC
eval	auto op1 = z.aux->ToListVal(frame);
	frame[z.v1].int_val = z.c.table_val->Find(op1) != nullptr;

internal-op Val-Is-In-Vector
type VVV
eval	auto& vec = frame[z.v3].vector_val;
	auto ind = frame[z.v2].int_val;
	frame[z.v1].int_val = ind >= 0 && ind < vec->Size();

internal-op Const-Is-In-Vector
type VCV
eval	auto& vec = frame[z.v2].vector_val;
	auto ind = z.c.int_val;
	frame[z.v1].int_val = ind >= 0 && ind < vec->Size();

expr-op Cond
type VVVV
set-type $3
eval	AssignV1(frame[z.v2].int_val ? CopyVal(frame[z.v3]) : CopyVal(frame[z.v4]))

expr-op Cond
type VVVC
set-type $3
eval	AssignV1(frame[z.v2].int_val ? CopyVal(frame[z.v3]) : CopyVal(z.c))

expr-op Cond
type VVCV
set-type $3
eval	AssignV1(frame[z.v2].int_val ? CopyVal(z.c) : CopyVal(frame[z.v3]))

op Bool-Vec-Cond
type VVVV
set-type $3
eval	auto& vsel = *frame[z.v2].vector_val->RawVec();
	auto& v1 = *frame[z.v3].vector_val->RawVec();
	auto& v2 = *frame[z.v4].vector_val->RawVec();
	auto n = v1.size();
	auto res = new vector<std::optional<ZVal>>(n);
	for ( auto i = 0U; i < n; ++i )
		if ( vsel[i] )
			(*res)[i] = vsel[i]->int_val ? v1[i] : v2[i];
	auto& full_res = frame[z.v1].vector_val;
	Unref(full_res);
	full_res = new VectorVal(cast_intrusive<VectorType>(z.t), res); 

# Our statement structure doesn't accommodate two constants, so for
# the singular case of a V ? C1 : C2 conditional, we split it into
# two operations, V ? C1 and !V ? C2.
op CondC1
type VVC
set-type $1
eval	if ( frame[z.v2].int_val )
		AssignV1(CopyVal(z.c))

op CondC2
set-type $1
type VVC
eval	if ( ! frame[z.v2].int_val )
		AssignV1(CopyVal(z.c))

########## Index Expressions ##########

op IndexVecBoolSelect
type VVV
set-type $1
eval	if ( frame[z.v2].vector_val->Size() != frame[z.v3].vector_val->Size() )
		{
		ZAM_run_time_error(z.loc, "size mismatch, boolean index and vector");
		break;
		}
	auto vt = cast_intrusive<VectorType>(z.t);
	auto v2 = frame[z.v2].vector_val;
	auto v3 = frame[z.v3].vector_val;
	auto v = vector_bool_select(vt, v2, v3);
	Unref(frame[z.v1].vector_val);
	frame[z.v1].vector_val = v.release();

op IndexVecBoolSelect
type VCV
set-type $1
eval	if ( z.c.vector_val->Size() != frame[z.v2].vector_val->Size() )
		{
		ZAM_run_time_error(z.loc, "size mismatch, boolean index and vector");
		break;
		}
	auto vt = cast_intrusive<VectorType>(z.t);
	auto v2 = z.c.vector_val;
	auto v3 = frame[z.v2].vector_val;
	auto v = vector_bool_select(vt, v2, v3);
	Unref(frame[z.v1].vector_val);
	frame[z.v1].vector_val = v.release();

op IndexVecIntSelect
type VVV
set-type $1
eval	auto vt = cast_intrusive<VectorType>(z.t);
	auto v2 = frame[z.v2].vector_val;
	auto v3 = frame[z.v3].vector_val;
	auto v = vector_int_select(vt, v2, v3);
	Unref(frame[z.v1].vector_val);
	frame[z.v1].vector_val = v.release();

op IndexVecIntSelect
type VCV
set-type $1
eval	auto vt = cast_intrusive<VectorType>(z.t);
	auto v2 = z.c.vector_val;
	auto v3 = frame[z.v2].vector_val;
	auto v = vector_int_select(vt, v2, v3);
	Unref(frame[z.v1].vector_val);
	frame[z.v1].vector_val = v.release();

op Index
type VVL
custom-method return CompileIndex(n1, n2, l);

op Index
type VCL
custom-method return CompileIndex(n, c, l);

internal-op Index-Vec
type VVV
eval	auto vv = frame[z.v2].vector_val->RawVec();
	const auto& vec = *vv;
	auto ind = frame[z.v3].uint_val;
	if ( ind >= vv->size() )
		ZAM_run_time_error(z.loc, "no such index");
	AssignV1(CopyVal(*vec[ind]))

internal-op Index-VecC
type VVV
eval	auto vv = frame[z.v2].vector_val->RawVec();
	const auto& vec = *vv;
	unsigned int ind = z.v3;
	if ( ind >= vv->size() )
		ZAM_run_time_error(z.loc, "no such index");
	AssignV1(CopyVal(*vec[ind]))

internal-op Index-Vec-Slice
type VV
eval	auto vec = frame[z.v2].vector_val;
	auto lv = z.aux->ToListVal(frame);
	auto v = index_slice(vec, lv.get());
	Unref(frame[z.v1].vector_val);
	frame[z.v1].vector_val = v.release();

internal-op Table-Index
type VV
eval	auto v2 = z.aux->ToListVal(frame);
	auto v = frame[z.v2].table_val->FindOrDefault(v2);
	if ( ! v )
		ZAM_run_time_error(z.loc, "no such index");
	AssignV1(BuildVal(v, z.t))

internal-assignment-op Table-Index1
type VVV
assign-val v
eval	auto v2 = frame[z.v3].ToVal(z.t);
	auto v = frame[z.v2].table_val->FindOrDefault(v2);
	if ( ! v )
		ZAM_run_time_error(z.loc, "no such index");

internal-assignment-op Table-Index1
type VVC
assign-val v
eval	auto v2 = z.c.ToVal(z.t);
	auto v = frame[z.v2].table_val->FindOrDefault(v2);
	if ( ! v )
		ZAM_run_time_error(z.loc, "no such index");

# This version is for a variable v3.
internal-op Index-String
type VVV
eval	auto str = frame[z.v2].string_val->AsString();
	auto len = str->Len();
	auto idx = frame[z.v3].int_val;
	if ( idx < 0 )
		idx += len;
	auto v = str->GetSubstring(idx, 1);
	Unref(frame[z.v1].string_val);
	frame[z.v1].string_val = new StringVal(v ? v : new String(""));

# This version is for a constant v3.
internal-op Index-StringC
type VVV
eval	auto str = frame[z.v2].string_val->AsString();
	auto len = str->Len();
	auto idx = z.v3;
	if ( idx < 0 )
		idx += len;
	auto v = str->GetSubstring(idx, 1);
	Unref(frame[z.v1].string_val);
	frame[z.v1].string_val = new StringVal(v ? v : new String(""));

internal-op Index-String-Slice
type VV
eval	auto str = frame[z.v2].string_val->AsString();
	auto lv = z.aux->ToListVal(frame);
	auto slice = index_string(str, lv.get());
	Unref(frame[z.v1].string_val);
	frame[z.v1].string_val = new StringVal(slice->ToStdString());

op AnyIndex
type VVi
set-type $1
eval	auto lv = frame[z.v2].any_val->AsListVal();
	if ( z.v3 < 0 || z.v3 >= lv->Length() )
		reporter->InternalError("bad \"any\" element index");
	ValPtr elem = lv->Idx(z.v3);
	if ( CheckAnyType(elem->GetType(), z.t, z.loc) )
		AssignV1(BuildVal(elem, z.t))
	else
		ZAM_error = true;


########## Constructors ##########

# Table construction requires atypical evaluation of list elements
# using information from their expression specifics.  We punt those
# back to the interpreter.
direct-unary-op Table-Constructor ConstructTable

internal-op Construct-Table
type VV
eval	auto tt = cast_intrusive<TableType>(z.t);
	auto new_t = new TableVal(tt, z.attrs);
	auto aux = z.aux;
	auto n = aux->n;
	auto ind_width = z.v2;
	for ( auto i = 0; i < n; ++i )
		{
		auto indices = aux->ToIndices(frame, i, ind_width);
		auto v = aux->ToVal(frame, i + ind_width);
		new_t->Assign(indices, v);
		i += ind_width;
		}
	auto& t = frame[z.v1].table_val;
	Unref(t);
	t = new_t;

direct-unary-op Set-Constructor ConstructSet

internal-op Construct-Set
type VV
eval	auto tt = cast_intrusive<TableType>(z.t);
	auto new_s = new TableVal(tt, z.attrs);
	auto aux = z.aux;
	auto n = aux->n;
	auto ind_width = z.v2;
	for ( auto i = 0; i < n; i += ind_width )
		{
		auto indices = aux->ToIndices(frame, i, ind_width);
		new_s->Assign(indices, nullptr);
		}
	auto& s = frame[z.v1].table_val;
	Unref(s);
	s = new_s;

direct-unary-op Record-Constructor ConstructRecord

internal-op Construct-Record
type V
eval	auto rt = cast_intrusive<RecordType>(z.t);
	auto new_r = new RecordVal(rt);
	auto aux = z.aux;
	auto n = aux->n;
	for ( auto i = 0; i < n; ++i )
		new_r->Assign(i, aux->ToVal(frame, i));
	auto& r = frame[z.v1].record_val;
	Unref(r);
	r = new_r;

internal-op Construct-Known-Record
type V
eval	auto rt = cast_intrusive<RecordType>(z.t);
	auto new_r = new RecordVal(rt);
	auto aux = z.aux;
	auto n = aux->n;
	auto& map = aux->map;
	for ( auto i = 0; i < n; ++i )
		new_r->Assign(map[i], aux->ToVal(frame, i));
	auto& r = frame[z.v1].record_val;
	Unref(r);
	r = new_r;

direct-unary-op Vector-Constructor ConstructVector

internal-op Construct-Vector
type V
eval	auto new_vv = new VectorVal(cast_intrusive<VectorType>(z.t));
	auto aux = z.aux;
	auto n = aux->n;
	for ( auto i = 0; i < n; ++i )
		new_vv->Assign(i, aux->ToVal(frame, i));
	auto& vv = frame[z.v1].vector_val;
	Unref(vv);
	vv = new_vv;

########## Coercions ##########

direct-unary-op Arith-Coerce ArithCoerce

internal-op Coerce-UI
type VV
eval	auto v = frame[z.v2].int_val;
	if ( v < 0 )
		{
		ZAM_run_time_error(z.loc, "underflow converting int to count");
		break;
		}
	frame[z.v1].uint_val = bro_uint_t(v);

internal-op Coerce-UI-Vec
type VV
eval	Unref(frame[z.v1].vector_val);
	frame[z.v1].vector_val = vec_coerce_UI(frame[z.v2].vector_val);

internal-op Coerce-UD
type VV
eval	auto v = frame[z.v2].double_val;
	if ( v < 0.0 )
		{
		ZAM_run_time_error(z.loc, "underflow converting double to count");
		break;
		}
	if ( v > UINT64_MAX )
		{
		ZAM_run_time_error(z.loc, "overflow converting double to count");
		break;
		}
	frame[z.v1].uint_val = bro_uint_t(v);

internal-op Coerce-UD-Vec
type VV
eval	Unref(frame[z.v1].vector_val);
	frame[z.v1].vector_val = vec_coerce_UD(frame[z.v2].vector_val);

internal-op Coerce-IU
type VV
eval	auto v = frame[z.v2].uint_val;
	if ( v > INT64_MAX )
		{
		ZAM_run_time_error(z.loc, "overflow converting count to int");
		break;
		}
	frame[z.v1].int_val = bro_int_t(v);

internal-op Coerce-IU-Vec
type VV
eval	Unref(frame[z.v1].vector_val);
	frame[z.v1].vector_val = vec_coerce_IU(frame[z.v2].vector_val);

internal-op Coerce-ID
type VV
eval	auto v = frame[z.v2].double_val;
	if ( v < static_cast<double>(INT64_MIN) )
		{
		ZAM_run_time_error(z.loc, "underflow converting double to int");
		break;
		}
	if ( v > static_cast<double>(INT64_MAX) )
		{
		ZAM_run_time_error(z.loc, "overflow converting double to int");
		break;
		}
	frame[z.v1].int_val = bro_int_t(v);

internal-op Coerce-ID-Vec
type VV
eval	Unref(frame[z.v1].vector_val);
	frame[z.v1].vector_val = vec_coerce_ID(frame[z.v2].vector_val);

internal-op Coerce-DI
type VV
eval	frame[z.v1].double_val = double(frame[z.v2].int_val);

internal-op Coerce-DI-Vec
type VV
eval	Unref(frame[z.v1].vector_val);
	frame[z.v1].vector_val = vec_coerce_DI(frame[z.v2].vector_val);

internal-op Coerce-DU
type VV
eval	frame[z.v1].double_val = double(frame[z.v2].uint_val);

internal-op Coerce-DU-Vec
type VV
eval	Unref(frame[z.v1].vector_val);
	frame[z.v1].vector_val = vec_coerce_DU(frame[z.v2].vector_val);

direct-unary-op Record-Coerce RecordCoerce

internal-op Record-Coerce
type VV
eval	auto rt = cast_intrusive<RecordType>(z.t);
	auto v = frame[z.v2].record_val;
	auto to_r = coerce_to_record(rt, v, z.aux->map);
	Unref(frame[z.v1].record_val);
	frame[z.v1].record_val = to_r.release();

direct-unary-op Table-Coerce TableCoerce

internal-op Table-Coerce
type VV
eval	auto tv = frame[z.v2].table_val;
	if ( tv->Size() > 0 )
		{
		ZAM_run_time_error(z.loc, "coercion of non-empty table/set");
		break;
		}
	auto tt = cast_intrusive<TableType>(z.t);
	AttributesPtr attrs = tv->GetAttrs();
	auto t = make_intrusive<TableVal>(tt, attrs);
	Unref(frame[z.v1].table_val);
	frame[z.v1].table_val = t.release();

direct-unary-op Vector-Coerce VectorCoerce

internal-op Vector-Coerce
type VV
eval	if ( frame[z.v2].vector_val->Size() > 0 )
		{
		ZAM_run_time_error(z.loc, "coercion of non-empty vector");
		break;
		}
	auto vv = new VectorVal(cast_intrusive<VectorType>(z.t));
	Unref(frame[z.v1].vector_val);
	frame[z.v1].vector_val = vv;

unary-expr-op To-Any-Coerce
op-type X
set-type $2
eval	AssignV1(ZVal(frame[z.v2].ToVal(z.t), any_base_type))

unary-expr-op From-Any-Coerce
op-type X
set-type $1
eval	auto v = frame[z.v2].any_val;
	AssignV1(ZVal({NewRef{}, v}, z.t))


########## Aggregate Assignments ##########

op Vector-Elem-Assign
op1-read
set-type $2
type VVV
eval	auto ind = frame[z.v2].uint_val;
	auto vv = frame[z.v1].vector_val;
	if ( ! copy_vec_elem(vv, ind, frame[z.v3], z.t) )
		ZAM_run_time_error(z.loc, "value used but not set");

op Any-Vector-Elem-Assign
op1-read
set-type $2
type VVV
eval	auto ind = frame[z.v2].uint_val;
	auto vv = frame[z.v1].vector_val;
	if ( ! vv->Assign(ind, frame[z.v3].ToVal(z.t)) )
		ZAM_run_time_error(z.loc, "vector index assignment failed for invalid type");

op Vector-Elem-Assign-Any
op1-read
type VVV
eval	auto ind = frame[z.v2].uint_val;
	auto vv = frame[z.v1].vector_val;
	auto any_v = frame[z.v3].any_val;
	if ( ! vv->Assign(ind, {NewRef{}, any_v}) )
		ZAM_run_time_error(z.loc, "vector index assignment failed for invalid type");

op Vector-Elem-Assign
op1-read
set-type $3
type VVC
eval	auto ind = frame[z.v2].uint_val;
	auto vv = frame[z.v1].vector_val;
	(void) copy_vec_elem(vv, ind, z.c, z.t);

op Any-Vector-Elem-Assign
op1-read
set-type $2
type VVC
eval	auto ind = frame[z.v2].uint_val;
	auto vv = frame[z.v1].vector_val;
	if ( ! vv->Assign(ind, z.c.ToVal(z.t)) )
		ZAM_run_time_error(z.loc, "vector index assignment failed for invalid type");

# These versions are used when the constant is the index, not the new value.
op Vector-Elem-Assign
op1-read
set-type $2
type VVi
eval	auto vv = frame[z.v1].vector_val;
	if ( ! copy_vec_elem(vv, z.v3, frame[z.v2], z.t) )
		ZAM_run_time_error(z.loc, "value used but not set");

op Any-Vector-Elem-Assign
op1-read
set-type $2
type VVi
eval	auto vv = frame[z.v1].vector_val;
	if ( ! vv->Assign(z.v3, frame[z.v2].ToVal(z.t)) )
		ZAM_run_time_error(z.loc, "value used but not set");

op Vector-Elem-Assign-Any
op1-read
type VVi
eval	auto vv = frame[z.v1].vector_val;
	auto any_v = frame[z.v2].any_val;
	vv->Assign(z.v3, {NewRef{}, any_v});

internal-op Vector-Slice-Assign
op1-read
type VV
eval	ValPtr vec = {NewRef{}, frame[z.v1].vector_val};
	auto slice = z.aux->ToListVal(frame);
	ValPtr vals = {NewRef{}, frame[z.v2].vector_val};
	bool iterators_invalidated;
	auto error = assign_to_index(vec, slice, vals, iterators_invalidated);
	if ( error )
		ZAM_run_time_error(z.loc, error);


internal-op Table-Elem-Assign
op1-read
type VV
eval	auto indices = z.aux->ToListVal(frame);
	auto val = frame[z.v2].ToVal(z.t);
	frame[z.v1].table_val->Assign(indices, val);

internal-op Table-Elem-Assign
op1-read
type VC
eval	auto indices = z.aux->ToListVal(frame);
	auto val = z.c.ToVal(z.t);
	frame[z.v1].table_val->Assign(indices, val);


########## Function Calls ##########

# A call with no arguments and no return value.
internal-op Call0
op1-read
type X
side-effects
num-call-args 0

# A call with no arguments and a return value.
internal-assignment-op Call0
type V
side-effects OP_CALL0_X OP_X
assign-val v
num-call-args 0

# Calls with 1 argument and no return value.
internal-op Call1
op1-read
type V
side-effects
num-call-args 1

internal-op Call1
op1-read
type C
side-effects
num-call-args 1

# Same but with a return value.
internal-assignment-op Call1
type VV
side-effects OP_CALL1_V OP_V
assign-val v
num-call-args 1

internal-assignment-op Call1
type VC
side-effects OP_CALL1_C OP_C
assign-val v
num-call-args 1

# Calls with 2-5 arguments and no return value.
internal-op Call2
type X
side-effects
num-call-args 2

# Same with a return value.
internal-assignment-op Call2
type V
side-effects OP_CALL2_X OP_X
assign-val v
num-call-args 2

internal-op Call3
type X
side-effects
num-call-args 3

# Same with a return value.
internal-assignment-op Call3
type V
side-effects OP_CALL3_X OP_X
assign-val v
num-call-args 3

internal-op Call4
type X
side-effects
num-call-args 4

# Same with a return value.
internal-assignment-op Call4
type V
side-effects OP_CALL4_X OP_X
assign-val v
num-call-args 4

internal-op Call5
type X
side-effects
num-call-args 5

# Same with a return value.
internal-assignment-op Call5
type V
side-effects OP_CALL5_X OP_X
assign-val v
num-call-args 5

# ... and with an arbitrary number of arguments.

internal-op CallN
type X
side-effects
num-call-args n

# Same with a return value.
internal-assignment-op CallN
type V
side-effects OP_CALLN_X OP_X
assign-val v
num-call-args n

# Same, but for indirect calls via a local variable.
internal-op IndCallN
op1-read
type V
side-effects
indirect-call
num-call-args n

# Same with a return value.
internal-assignment-op IndCallN
type VV
side-effects OP_INDCALLN_V OP_V
assign-val v
indirect-call
num-call-args n

########## Statements ##########

op Schedule
type ViHL
op1-read
custom-method return CompileSchedule(n, nullptr, i, h, l);
eval	if ( run_state::terminating )
		break;
	double dt = frame[z.v1].double_val;
	if ( z.v2 ) dt += run_state::network_time;
	auto handler = EventHandlerPtr(z.event_handler);
	val_vec args;
	z.aux->FillValVec(args, frame);
	auto timer = new ScheduleTimer(handler, std::move(args), dt);
	timer_mgr->Add(timer);

op Schedule
type CiHL
op1-read
custom-method return CompileSchedule(nullptr, c, i, h, l);
eval	if ( run_state::terminating )
		break;
	double dt = z.c.double_val;
	if ( z.v1 ) dt += run_state::network_time;
	auto handler = EventHandlerPtr(z.event_handler);
	val_vec args;
	z.aux->FillValVec(args, frame);
	auto timer = new ScheduleTimer(handler, std::move(args), dt);
	timer_mgr->Add(timer);

internal-op Schedule0
type ViH
op1-read
eval	if ( run_state::terminating )
		break;
	double dt = frame[z.v1].double_val;
	if ( z.v2 ) dt += run_state::network_time;
	auto handler = EventHandlerPtr(z.event_handler);
	val_vec args;
	auto timer = new ScheduleTimer(handler, std::move(args), dt);
	timer_mgr->Add(timer);

internal-op Schedule0
type CiH
op1-read
eval	if ( run_state::terminating )
		break;
	double dt = z.c.double_val;
	if ( z.v1 ) dt += run_state::network_time;
	auto handler = EventHandlerPtr(z.event_handler);
	val_vec args;;
	auto timer = new ScheduleTimer(handler, std::move(args), dt);
	timer_mgr->Add(timer);


op Event
type HL
op1-read
custom-method return CompileEvent(h, l);
eval	val_vec args;
	z.aux->FillValVec(args, frame);
	event_mgr.Enqueue(z.event_handler, std::move(args));

internal-op Event0
type X
eval	val_vec args(0);
	event_mgr.Enqueue(z.event_handler, std::move(args));

internal-op Event1
type V
op1-read
eval	val_vec args(1);
	args[0] = frame[z.v1].ToVal(z.t);
	event_mgr.Enqueue(z.event_handler, std::move(args));

internal-op Event2
type VV
op1-read
eval	val_vec args(2);
	args[0] = frame[z.v1].ToVal(z.t);
	args[1] = frame[z.v2].ToVal(z.t2);
	event_mgr.Enqueue(z.event_handler, std::move(args));

internal-op Event3
type VVV
op1-read
eval	val_vec args(3);
	args[0] = frame[z.v1].ToVal(z.t);
	args[1] = frame[z.v2].ToVal(z.t2);
	auto types = z.aux->types;
	args[2] = frame[z.v3].ToVal(types[2]);
	event_mgr.Enqueue(z.event_handler, std::move(args));

internal-op Event4
type VVVV
op1-read
eval	val_vec args(4);
	args[0] = frame[z.v1].ToVal(z.t);
	args[1] = frame[z.v2].ToVal(z.t2);
	auto types = z.aux->types;
	args[2] = frame[z.v3].ToVal(types[2]);
	args[3] = frame[z.v4].ToVal(types[3]);
	event_mgr.Enqueue(z.event_handler, std::move(args));


op Return
type X
eval	ret_u = nullptr;
	pc = end_pc;
	continue;

op Return
op1-read
type V
set-type $1
eval	ret_u = &frame[z.v1];
	ret_type = z.t;
	pc = end_pc;
	continue;

op Return
type C
eval	ret_u = &z.c;
	ret_type = z.t;
	pc = end_pc;
	continue;


# Branch on the value of v1 using switch table v2, with default branch to v3
internal-op SwitchI
type VVV
op1-read
eval	auto v = frame[z.v1].int_val;
	SWITCH_BODY(int_cases,)

internal-op SwitchU
op1-read
type VVV
eval	auto v = frame[z.v1].uint_val;
	SWITCH_BODY(uint_cases,)

internal-op SwitchD
op1-read
type VVV
eval	auto v = frame[z.v1].double_val;
	SWITCH_BODY(double_cases,)

internal-op SwitchS
op1-read
type VVV
eval	auto vs = frame[z.v1].string_val->AsString()->Render();
	std::string v(vs);
	SWITCH_BODY(str_cases,delete[] vs;)

internal-op SwitchA
op1-read
type VVV
eval	auto v = frame[z.v1].addr_val->AsAddr().AsString();
	SWITCH_BODY(str_cases,)

internal-op SwitchN
op1-read
type VVV
eval	auto v = frame[z.v1].subnet_val->AsSubNet().AsString();
	SWITCH_BODY(str_cases,)
	auto t = str_cases[z.v2];


internal-op Branch-If-Not-Type
op1-read
type VV
eval	auto v = frame[z.v1].any_val;
	if ( ! can_cast_value_to_type(v, z.t.get()) )
		BRANCH(v2)


internal-op Init-Table-Loop
type VV
eval	auto ii = z.aux->iter_info;
	auto tv = frame[z.v2].table_val;
	auto tvd = tv->AsTable();
	ii->tv = tv;
	ii->tbl_iter = tvd->begin();
	ii->tbl_end = tvd->end();
	ii->value_var_type = z.t;
	frame[z.v1].iter_info = ii;

internal-op Init-Table-Loop-Recursive
type VVV
eval	auto ii = z.aux->iter_info;
	auto& nii = (*iters)[z.v3];
	nii.loop_vars = ii->loop_vars;
	nii.loop_var_types = ii->loop_var_types;
	ii = &nii;
	auto tv = frame[z.v2].table_val;
	auto tvd = tv->AsTable();
	ii->tv = tv;
	ii->tbl_iter = tvd->begin();
	ii->tbl_end = tvd->end();
	ii->value_var_type = z.t;
	frame[z.v1].iter_info = ii;

internal-op Next-Table-Iter
op1-read
# v1 = iteration info
# v2 = branch target if loop done
type VV
eval	auto ii = frame[z.v1].iter_info;
	auto& current_tev = *ii->tbl_iter;
	if ( current_tev == *ii->tbl_end )
		BRANCH(v2)
	auto ind_lv = ii->tv->RecreateIndex(*current_tev->GetHashKey());
	for ( int i = 0; i < ind_lv->Length(); ++i )
		{
		ValPtr ind_lv_p = ind_lv->Idx(i);
		auto t = ii->loop_var_types[i];
		auto& var = frame[ii->loop_vars[i]];
		if ( ZVal::IsManagedType(t) )
			ZVal::DeleteManagedType(var);
		var = BuildVal(ind_lv_p, ii->loop_var_types[i]);
		}
	++current_tev;

internal-op Next-Table-Iter-No-Vars
op1-read
# v1 = iteration info
# v2 = branch target if loop done
type VV
eval	auto ii = frame[z.v1].iter_info;
	auto& current_tev = *ii->tbl_iter;
	if ( current_tev == *ii->tbl_end )
		BRANCH(v2)
	++current_tev;

internal-op Next-Table-Iter-Val-Var
# v1 = slot of the "ValueVar"
# v2 = iteration info
# v3 = branch target if loop done
type VVV
eval	auto ii = frame[z.v2].iter_info;
	auto& current_tev = *ii->tbl_iter;
	if ( current_tev == *ii->tbl_end )
		BRANCH(v3)
	auto ind_lv = ii->tv->RecreateIndex(*current_tev->GetHashKey());
	auto tev = current_tev->GetValue<TableEntryVal*>();
	auto val_var_t = ii->value_var_type;
	if ( z.is_managed )
		ZVal::DeleteManagedType(frame[z.v1]);
	frame[z.v1] = BuildVal(tev->GetVal(), val_var_t);
	for ( int i = 0; i < ind_lv->Length(); i++ )
		{
		ValPtr ind_lv_p = ind_lv->Idx(i);
		auto ind = ii->loop_vars[i];
		auto loop_var_t = ii->loop_var_types[i];
		if ( ZVal::IsManagedType(loop_var_t) )
			ZVal::DeleteManagedType(frame[ind]);
		frame[ind] = BuildVal(ind_lv_p, loop_var_t);
		}
	++current_tev;

internal-op Next-Table-Iter-Val-Var-No-Vars
# v1 = slot of the "ValueVar"
# v2 = iteration info
# v3 = branch target if loop done
type VVV
eval	auto ii = frame[z.v2].iter_info;
	auto& current_tev = *ii->tbl_iter;
	if ( current_tev == *ii->tbl_end )
		BRANCH(v3)
	auto tev = current_tev->GetValue<TableEntryVal*>();
	auto val_var_t = ii->value_var_type;
	if ( z.is_managed )
		ZVal::DeleteManagedType(frame[z.v1]);
	frame[z.v1] = BuildVal(tev->GetVal(), val_var_t);
	++current_tev;

internal-op Init-Vector-Loop
type VV
eval	auto ii = z.aux->iter_info;
	ii->vv = frame[z.v2].vector_val->RawVec();
	ii->n = ii->vv->size();
	ii->iter = 0;
	frame[z.v1].iter_info = ii;

internal-op Init-Vector-Loop-Recursive
type VVV
eval	auto ii = z.aux->iter_info;
	auto& nii = (*iters)[z.v3];
	nii.vec_type = ii->vec_type;
	nii.yield_type = ii->yield_type;
	ii = &nii;
	ii->vv = frame[z.v2].vector_val->RawVec();
	ii->n = ii->vv->size();
	ii->iter = 0;
	frame[z.v1].iter_info = ii;

internal-op Next-Vector-Iter
# v1 = iteration variable
# v2 = iteration info
# v3 = branch target if loop done
type VVV
eval	auto ii = frame[z.v2].iter_info;
	if ( ii->iter >= ii->n )
		BRANCH(v3)
	const auto& vv = *ii->vv;
	if ( ! vv[ii->iter] )
		{
		++ii->iter;
		--pc;
		break;
		}
	frame[z.v1].uint_val = ii->iter;
	++ii->iter;

internal-op Init-String-Loop
type VV
eval	auto ii = z.aux->iter_info;
	ii->s = frame[z.v2].string_val->AsString();
	ii->iter = 0;
	ii->n = ii->s->Len();
	frame[z.v1].iter_info = ii;

internal-op Init-String-Loop-Recursive
type VVV
eval	auto ii = &(*iters)[z.v3];
	ii->s = frame[z.v2].string_val->AsString();
	ii->iter = 0;
	ii->n = ii->s->Len();
	frame[z.v1].iter_info = ii;

internal-op Next-String-Iter
# v1 = iteration variable
# v2 = iteration info
# v3 = branch target if loop done
type VVV
eval	auto ii = frame[z.v2].iter_info;
	auto sval = ii->s;
	if ( ii->iter >= ii->n )
		BRANCH(v3)
	auto bytes = (const char*) sval->Bytes() + ii->iter;
	auto sv = new StringVal(1, bytes);
	Unref(frame[z.v1].string_val);
	frame[z.v1].string_val = sv;
	++ii->iter;

internal-op End-Loop
op1-read
type V
eval	auto& ii = frame[z.v1].iter_info;
	ii->vv = nullptr;	// not strictly needed

internal-op End-Table-Loop
op1-read
type V
eval	auto& ii = frame[z.v1].iter_info;
	ii->tbl_iter = std::nullopt;
	ii->tbl_end = std::nullopt;


op When
op1-read
type VVVV
eval	auto when_body = new ZAMResumption(this, z.v2);
	auto timeout_body = new ZAMResumption(this, z.v3);
	new trigger::Trigger(z.e, when_body, timeout_body, frame[z.v1].double_val, f, z.v4, z.loc);

op When
type VVVC
eval	auto when_body = new ZAMResumption(this, z.v1);
	auto timeout_body = new ZAMResumption(this, z.v2);
	new trigger::Trigger(z.e, when_body, timeout_body, z.c.double_val, f, z.v3, z.loc);

op When
type VV
eval	auto when_body = new ZAMResumption(this, z.v2);
	new trigger::Trigger(z.e, when_body, nullptr, -1.0, f, z.v1, z.loc);

op CheckAnyLen
op1-read
type Vi
eval	auto v = frame[z.v1].list_val;
	if ( v->Vals().size() != z.v2 )
		ZAM_run_time_error(z.loc, "mismatch in list lengths");

op Print
type O
eval	do_print_stmt(z.aux->ToValVec(frame));
method-post z.aux = v->aux;

op Print1
op1-read
type V
set-type $1
eval	std::vector<ValPtr> vals;
	vals.push_back(frame[z.v1].ToVal(z.t));
	do_print_stmt(vals);

op Print1
op1-read
type C
set-type $1
eval	std::vector<ValPtr> vals;
	vals.push_back(z.c.ToVal(z.t));
	do_print_stmt(vals);


internal-op If-Else
op1-read
type VV
eval	if ( ! frame[z.v1].int_val ) BRANCH(v2)

internal-op If
op1-read
type VV
eval	if ( ! frame[z.v1].int_val ) BRANCH(v2)

internal-op If-Not
op1-read
type VV
eval	if ( frame[z.v1].int_val ) BRANCH(v2)


op AddStmt
op1-read
type VO
eval	auto index = z.aux->ToListVal(frame);
	frame[z.v1].table_val->Assign(index, nullptr);
method-post z.aux = v->aux;

op AddStmt1
op1-read
set-type $2
type VV
eval	auto index = frame[z.v2].ToVal(z.t);
	frame[z.v1].table_val->Assign(index, nullptr);

op AddStmt1
op1-read
type VC
eval	auto index = z.c.ToVal(z.t);
	frame[z.v1].table_val->Assign(index, nullptr);


op DelTable
op1-read
type VO
eval	auto index = z.aux->ToListVal(frame);
	frame[z.v1].table_val->Remove(*index);
method-post z.aux = v->aux;

op DelField
op1-read
type Vi
eval	frame[z.v1].record_val->Remove(z.v2);


internal-op Init-Record
type V
eval	auto r = new RecordVal(cast_intrusive<RecordType>(z.t));
	Unref(frame[z.v1].record_val);
	frame[z.v1].record_val = r;

internal-op Init-Vector
type V
eval	auto vt = cast_intrusive<VectorType>(z.t);
	auto vec = new VectorVal(vt);
	Unref(frame[z.v1].vector_val);
	frame[z.v1].vector_val = vec;

internal-op Init-Table
type V
eval	auto tt = cast_intrusive<TableType>(z.t);
	auto t = new TableVal(tt, z.attrs);
	Unref(frame[z.v1].table_val);
	frame[z.v1].table_val = t;


########################################
# Internal
########################################

op Sync-Globals
type X
eval	for ( auto i = 0; i < num_globals; ++i )
		{
		if ( global_state[i] == GS_DIRTY )
			{
			auto id = globals[i].id;
			auto slot = globals[i].slot;
			auto v = frame[slot].ToVal(id->GetType());
			id->SetVal(v);
			}
		global_state[i] = GS_UNLOADED;
		}

op Dirty-Global
op1-internal
type V
eval	global_state[z.v1] = GS_DIRTY;

# These two are only needed for type-based switch statements.  Could think
# about replacing them using CoerceFromAnyExpr.
op Assign-Any
type VV
set-type $2
eval	auto v = frame[z.v2].ToVal(z.t);
	frame[z.v1].any_val = v.release();

op Assign-Any
type VC
set-type $2
eval	auto v = z.c.ToVal(z.t);
	frame[z.v1].any_val = v.release();

# Lazy way to assign without having to track the specific type of
# a constant.
internal-op Assign-Const
type VC
eval	AssignV1(BuildVal(z.c.ToVal(z.t), z.t))

internal-assignment-op Load-Val
type VV
assign-val v
eval	auto v = f->GetElement(z.v2);

internal-assignment-op Load-Global
type VV
assign-val v
eval	if ( global_state[z.v2] != GS_UNLOADED )
		break;
	global_state[z.v2] = GS_CLEAN;
	auto v = z.aux->id_val->GetVal();
	if ( ! v )
		{
		ZAM_run_time_error(z.loc, "value used but not set", z.aux->id_val);
		break;
		}

# We need a special form here for loading global types, as they don't
# fit the usual template.
internal-op Load-Global-Type
type VV
eval	if ( global_state[z.v2] != GS_UNLOADED )
		break;
	global_state[z.v2] = GS_CLEAN;
	auto& v = frame[z.v1].type_val;
	Unref(v);
	auto t = z.aux->id_val->GetType();
	v = new TypeType(t);

internal-op Store-Val
op1-read
type VV
eval	auto val = frame[z.v1].ToVal(z.t);
	f->SetElement(z.v2, val);

### This now should work as just an ordinary Store-Val.
internal-op Store-Any-Val
op1-read
type VV
eval	f->SetElement(z.v2, {NewRef{}, frame[z.v1].any_val});

internal-op Copy-To
type VC
set-type $2
eval	AssignV1(CopyVal(z.c))

internal-op GoTo
type V
eval	BRANCH(v1)

internal-op Hook-Break
type X
eval	flow = FLOW_BREAK;
	pc = end_pc;
	continue;


########################################
# Built-in Functions
########################################

internal-op Sub-Bytes
type VVVV
eval	SUB_BYTES(frame[z.v2], frame[z.v3].uint_val, frame[z.v4].int_val)

internal-op Sub-Bytes
type VVVi
eval	SUB_BYTES(frame[z.v2], frame[z.v3].uint_val, z.v4)

internal-op Sub-Bytes
type VViV
eval	SUB_BYTES(frame[z.v2], bro_uint_t(z.v4), frame[z.v3].int_val)

internal-op Sub-Bytes
type VVii
eval	SUB_BYTES(frame[z.v2], bro_uint_t(z.v3), z.v4)

internal-op Sub-Bytes
type VVVC
eval	SUB_BYTES(z.c, frame[z.v2].uint_val, frame[z.v3].uint_val)

internal-op Sub-Bytes
type VViC
eval	SUB_BYTES(z.c, frame[z.v2].uint_val, z.v3)

internal-op Sub-Bytes
type ViVC
eval	SUB_BYTES(z.c, bro_uint_t(z.v3), frame[z.v2].uint_val)

internal-op Sub-Bytes
type ViiC
eval	SUB_BYTES(z.c, bro_uint_t(z.v2), z.v3)

internal-op To-Lower
type VV
eval	auto sv = ZAM_to_lower(frame[z.v2].string_val);
	Unref(frame[z.v1].string_val);
	frame[z.v1].string_val = sv;

# A ZAM version of Log::__write.  In calls to it, the first argument
# is generally a constant (enum) *if we inlined*, but otherwise a
# parameter, so we support both VVV ad VVC.
#
# It's actually the case that the return value is pretty much always
# ignored ... plus optimization can elide it away.  See the second
# pair of built-ins for versions that discard the return value.
#
# Could speed things up further by modifying the Write method to just
# take the raw enum value, as it appears that that's all that's ever
# actually used.

internal-op Log-Write
side-effects
type VVV
eval	auto id = frame[z.v2].ToVal(log_ID_enum_type);
	auto columns = frame[z.v3].ToVal(z.t);
	bool result = log_mgr->Write(id->AsEnumVal(), columns->AsRecordVal());
	frame[z.v1].int_val = result;

internal-op Log-WriteC
side-effects
type VV
eval	auto id = z.aux->constants[0];
	auto columns = frame[z.v2].ToVal(z.t);
	bool result = log_mgr->Write(id->AsEnumVal(), columns->AsRecordVal());
	frame[z.v1].int_val = result;

# Versions that discard the return value.
internal-op Log-Write
side-effects
op1-read
type VV
eval	auto id = frame[z.v1].ToVal(log_ID_enum_type);
	auto columns = frame[z.v2].ToVal(z.t);
	(void) log_mgr->Write(id->AsEnumVal(), columns->AsRecordVal());

internal-op Log-WriteC
side-effects
op1-read
type V
eval	auto id = z.aux->constants[0];
	auto columns = frame[z.v1].ToVal(z.t);
	(void) log_mgr->Write(id->AsEnumVal(), columns->AsRecordVal());

internal-op Broker-Flush-Logs
side-effects
type V
eval	frame[z.v1].uint_val = broker_mgr->FlushLogBuffers();

internal-op Broker-Flush-Logs
side-effects
type X
eval	(void) broker_mgr->FlushLogBuffers();

internal-op Get-Port-Transport-Proto
type VV
eval	auto mask = frame[z.v2].uint_val & PORT_SPACE_MASK;
	auto v = 0; /* TRANSPORT_UNKNOWN */
	if ( mask == TCP_PORT_MASK )
		v = 1;
	else if ( mask == UDP_PORT_MASK )
		v = 2;
	else if ( mask == ICMP_PORT_MASK )
		v = 3;
	frame[z.v1].uint_val = v;

internal-op Network-Time
type V
eval	frame[z.v1].double_val = run_state::network_time;

internal-op Current-Time
type V
eval	frame[z.v1].double_val = util::current_time();

internal-op Reading-Live-Traffic
type V
eval	frame[z.v1].int_val = run_state::reading_live;

internal-op Reading-Traces
type V
eval	frame[z.v1].int_val = run_state::reading_traces;

internal-op StrStr
type VVV
eval	auto big = frame[z.v2].string_val;
	auto little = frame[z.v3].string_val;
	frame[z.v1].int_val = 1 + big->AsString()->FindSubstring(little->AsString());

internal-op StrStr
type VCV
eval	auto big = z.c.string_val;
	auto little = frame[z.v2].string_val;
	frame[z.v1].int_val = 1 + big->AsString()->FindSubstring(little->AsString());

internal-op StrStr
type VVC
eval	auto big = frame[z.v2].string_val;
	auto little = z.c.string_val;
	frame[z.v1].int_val = 1 + big->AsString()->FindSubstring(little->AsString());

internal-op Analyzer--Name
type VV
eval	auto atype = frame[z.v2].ToVal(z.t);
	auto& name = analyzer_mgr->GetComponentName(cast_intrusive<EnumVal>(atype));
	Unref(frame[z.v1].string_val);
	frame[z.v1].string_val = new StringVal(name);

internal-op Files--Enable-Reassembly
op1-read
type V
eval	auto f = frame[z.v1].string_val->CheckString();
	file_mgr->EnableReassembly(f);

internal-op Files--Set-Reassembly-Buffer
op1-read
type VV
eval	auto f = frame[z.v1].string_val->CheckString();
	file_mgr->SetReassemblyBuffer(f, frame[z.v2].uint_val);

internal-op Files--Set-Reassembly-Buffer
op1-read
type VC
eval	auto f = frame[z.v1].string_val->CheckString();
	file_mgr->SetReassemblyBuffer(f, bro_uint_t(z.v2));
